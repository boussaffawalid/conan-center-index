diff --git a/src/openslide-decode-tifflike.c b/src/openslide-decode-tifflike.c
index 63e0ad5..d7a3052 100644
--- a/src/openslide-decode-tifflike.c
+++ b/src/openslide-decode-tifflike.c
@@ -109,9 +109,11 @@ static void fix_byte_order(void *data, int32_t size, int64_t count,
 static uint64_t read_uint(FILE *f, int32_t size, bool big_endian, bool *ok) {
   g_assert(ok != NULL);
 
-  uint8_t buf[size];
+  uint8_t *buf = malloc(size);
+
   if (fread(buf, size, 1, f) != 1) {
     *ok = false;
+    free (buf);
     return 0;
   }
   fix_byte_order(buf, sizeof(buf), 1, big_endian);
@@ -119,21 +121,25 @@ static uint64_t read_uint(FILE *f, int32_t size, bool big_endian, bool *ok) {
   case 1: {
     uint8_t result;
     memcpy(&result, buf, sizeof(result));
+    free (buf);
     return result;
   }
   case 2: {
     uint16_t result;
     memcpy(&result, buf, sizeof(result));
+    free (buf);
     return result;
   }
   case 4: {
     uint32_t result;
     memcpy(&result, buf, sizeof(result));
+    free (buf);
     return result;
   }
   case 8: {
     uint64_t result;
     memcpy(&result, buf, sizeof(result));
+    free (buf);
     return result;
   }
   default:
@@ -348,7 +354,12 @@ static bool populate_item(struct _openslide_tifflike *tl,
   uint64_t count = item->count;
   int32_t value_size = get_value_size(item->type, &count);
   g_assert(value_size);
+
+#ifdef _MSC_VER  
+  ptrdiff_t len = value_size * count;
+#else
   ssize_t len = value_size * count;
+#endif
 
   buf = g_try_malloc(len);
   if (buf == NULL) {
@@ -485,17 +496,23 @@ static struct tiff_directory *read_directory(FILE *f, int64_t *diroff,
     }
 
     // check for overflow
+#ifdef _MSC_VER
+    if (count > PTRDIFF_MAX / value_size) {
+#else
     if (count > SSIZE_MAX / value_size) {
+#endif
       g_set_error(err, OPENSLIDE_ERROR, OPENSLIDE_ERROR_FAILED,
                   "Value count too large");
       goto FAIL;
     }
 
     // read in the value/offset
-    uint8_t value[bigtiff ? 8 : 4];
+    uint8_t* value = malloc(bigtiff ? 8 : 4);
+
     if (fread(value, sizeof(value), 1, f) != 1) {
       g_set_error(err, OPENSLIDE_ERROR, OPENSLIDE_ERROR_FAILED,
                   "Cannot read value/offset");
+      free(value);
       goto FAIL;
     }
 
@@ -504,6 +521,7 @@ static struct tiff_directory *read_directory(FILE *f, int64_t *diroff,
       // yes
       fix_byte_order(value, value_size, count, big_endian);
       if (!set_item_values(item, value, err)) {
+        free(value);
         goto FAIL;
       }
 
@@ -518,6 +536,7 @@ static struct tiff_directory *read_directory(FILE *f, int64_t *diroff,
         fix_byte_order(&off32, sizeof(off32), 1, big_endian);
         item->offset = off32;
       }
+      free(value);
 
       if (ndpi) {
         // heuristically set high-order bits of offset
diff --git a/src/openslide-dll.rc.in b/src/openslide-dll.rc.in
index 08bae48..9fe60a0 100644
--- a/src/openslide-dll.rc.in
+++ b/src/openslide-dll.rc.in
@@ -1,7 +1,7 @@
 #include "winuser.h"
 #include "winver.h"
 
-2 RT_MANIFEST openslide-dll.manifest
+2 RT_MANIFEST "openslide-dll.manifest"
 
 1 VERSIONINFO
 FILEVERSION @WINDOWS_VERSIONINFO@
diff --git a/src/openslide-private.h b/src/openslide-private.h
index a70bcba..3f6ba74 100644
--- a/src/openslide-private.h
+++ b/src/openslide-private.h
@@ -34,6 +34,15 @@
 
 #include <cairo.h>
 
+#ifdef _MSC_VER
+#ifndef fseeko
+#define fseeko _fseeki64
+#define ftello _ftelli64
+#endif
+#endif
+
+
+
 /* the associated image structure */
 struct _openslide_associated_image {
   const struct _openslide_associated_image_ops *ops;
